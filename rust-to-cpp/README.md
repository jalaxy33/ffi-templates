# Rust to C++ template

A simple template for creating a Rust library that can be called from C++. 


**Hint**: You can initialize a rust library by running `cargo new --lib <library-name>`.


## Requirements

- **C++ compiler**: g++/clang++/MSVC
- **[CMake](https://cmake.org/download/) build tools**
- **[Rust toolchain](https://www.rust-lang.org/tools/install)**


## Toolchain

- [cbindgen](https://github.com/mozilla/cbindgen): Generates C/C++ header files from Rust source files. Install it via `cargo add cbindgen --build`.


## Usage

```bash
# 1. Build the Rust library
cargo b  # Debug build
cargo b -r  # Release build

# 2. Configure and build C++ target
cmake -B build && cmake --build build  # Debug build
cmake -B build && cmake --build build --config Release  # Release build

# 3. Run the executable, change `demo` to actual target name 
./build/Debug/demo.exe  # On Windows
./build/Debug/demo      # On Linux/Mac
```


## Keypoints

### 1. Build Rust shared library

Build the Rust code as a shared library by specifying the crate type `cdylib` in `Cargo.toml`:

```toml
[lib]
crate-type = ["rlib", "cdylib"]
```

### 2. Generate C/C++ header files

We can use `cbindgen` to generate C/C++ header files automatically during compile time. We can set this build behavior in [build.rs](./build.rs):

```rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let crate_path = PathBuf::from(&crate_dir);

    // Generate Rust to C++ binding headers
    cbindgen::Builder::new()
        .with_crate(&crate_path)
        .with_header("/* WARNING: This file is automatically generated by cbindgen. Do not modify manually! */\n#pragma once")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(crate_path.join("include/rust_to_cpp.h"));

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=src/rust_to_cpp.rs");
    println!("cargo:rerun-if-changed=src/call_cpp.rs");
}

```


### 3. Link Rust shared library to C++ target

**step 1**: Set up the Rust library path in [CMakeLists.txt](./CMakeLists.txt):

```cmake
# =============================================================================
# Rust Library Configuration
# =============================================================================

set(RUST_LIB_NAME "rust_to_cpp")  # change this to actual Rust library name
set(RUST_TARGET_DIR "${CMAKE_SOURCE_DIR}/target")
if (CMAKE_BUILD_TYPE STREQUAL "Debug")
    set(RUST_LIB_DIR "${RUST_TARGET_DIR}/debug")
    message(STATUS "Debug build")
else()
    set(RUST_LIB_DIR "${RUST_TARGET_DIR}/release")
    message(STATUS "Release build")
endif()

if (WIN32)
    set(RUST_LIB_PATH "${RUST_LIB_DIR}/${RUST_LIB_NAME}.dll")
elseif(APPLE)
    set(RUST_LIB_PATH "${RUST_LIB_DIR}/lib${RUST_LIB_NAME}.dylib")
else()
    set(RUST_LIB_PATH "${RUST_LIB_DIR}/lib${RUST_LIB_NAME}.so")
endif()

if (EXISTS ${RUST_LIB_PATH})
    message(STATUS "Rust lib exists")
else()
    message(FATAL_ERROR "Rust lib does not exist: ${RUST_LIB_PATH}. Please build the Rust library first.")
endif()
```

**step 2**: Link the Rust shared library to the C++ target (and copy dll to target output on Windows) in [CMakeLists.txt](./CMakeLists.txt):

```cmake
# link the Rust shared library
if(WIN32) 
    # NOTE: On Windows, there are two types of libraries: the import library (.dll.lib) and the runtime library (.dll)
    target_link_libraries(${targetname} PRIVATE "${RUST_LIB_PATH}.lib")

    # Copy DLL to output directory on Windows
    add_custom_command(TARGET ${targetname} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy
        "${RUST_LIB_PATH}"
        $<TARGET_FILE_DIR:${targetname}>
        COMMENT "Copying ${RUST_LIB_NAME}.dll to output directory"
    )
elseif(APPLE)
    target_link_libraries(${targetname} PRIVATE "${RUST_LIB_PATH}")
else()
    target_link_libraries(${targetname} PRIVATE "${RUST_LIB_PATH}")
endif()
```



cmake_minimum_required(VERSION 3.10.0)
project(python-to-cpp VERSION 0.1.0 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 17)

# --------------------------------------------------------------------------------
# Functions to setup Python and pybind11
# --------------------------------------------------------------------------------


function(setup_python targetname)
    # find uv executable
    find_program(UV_EXECUTABLE uv REQUIRED)

    # install python dependencies if not exist
    set(VENV_DIR ${CMAKE_SOURCE_DIR}/.venv)
    if (WIN32)
        set(PYTHON_EXECUTABLE ${VENV_DIR}/Scripts/python.exe)
    else()
        set(PYTHON_EXECUTABLE ${VENV_DIR}/bin/python)
    endif()

    if (NOT EXISTS ${VENV_DIR} OR NOT EXISTS ${PYTHON_EXECUTABLE})
        message(WARNING "No available Python environment found. Running 'uv sync' to install python dependencies...")
        execute_process(
            COMMAND uv sync
            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        )
    else()
        message(STATUS "Using existing Python environment at: ${VENV_DIR}")
    endif()

    # set pybind11 dependency
    set(pybind11_ROOT ${VENV_DIR}/Lib/site-packages/pybind11)
    set(pybind11_DIR ${pybind11_ROOT}/share/cmake/pybind11)
    set(Python_EXECUTABLE ${PYTHON_EXECUTABLE})  # for compatibility with pybind11

    if (NOT EXISTS ${pybind11_ROOT} OR NOT EXISTS ${pybind11_DIR})
        message(FATAL_ERROR "Dependency 'pybind11' not found. Please install 'pybind11' first by 'uv add pybind11 --dev'.")
    endif()

    # find pybind11 package for CMake
    set(PYBIND11_FINDPYTHON ON)
    find_package(pybind11 CONFIG REQUIRED)

    # link pybind11 to target
    target_link_libraries(${targetname} PRIVATE pybind11::embed)

    # Get python info
    execute_process(
        COMMAND ${PYTHON_EXECUTABLE} -c "import sysconfig; print(sysconfig.get_config_var('installed_platbase'))"
        OUTPUT_VARIABLE PYTHON_SYS_ROOT
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    execute_process(
        COMMAND ${PYTHON_EXECUTABLE} -c "import sysconfig; print(sysconfig.get_config_var('py_version_nodot'))"
        OUTPUT_VARIABLE PYTHON_SHORT_VERSION
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )

    string(REPLACE "\\" "/" PYTHON_SYS_ROOT "${PYTHON_SYS_ROOT}")
    
    # Windows specific settings: copy python lib DLL to output directory
    if (WIN32)
        # Determine the python DLL name
        set(PYTHON_LIB_NAME "python${PYTHON_SHORT_VERSION}")
        set(PYTHON_LIB "${PYTHON_SYS_ROOT}/${PYTHON_LIB_NAME}.dll")

        if (NOT EXISTS ${PYTHON_LIB})
            message(FATAL_ERROR "Python lib not found at '${PYTHON_LIB}'.")
        endif()

        add_custom_command(TARGET ${targetname} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
            ${PYTHON_LIB}
            $<TARGET_FILE_DIR:${targetname}>
            COMMENT "Copying ${PYTHON_LIB_NAME}.dll to output directory."
        )
    endif()

    # Define compiler definitions to ensure correct runtime python environment
    set(PYTHON_HOME_PATH "${PYTHON_SYS_ROOT}")  # set runtime PYTHONHOME environment variable
    set(VENV_PACKAGES_DIR "${VENV_DIR}/Lib/site-packages")  # pass virtual environment site-packages to runtime

    string(REPLACE "\\" "/" PYTHON_HOME_PATH "${PYTHON_HOME_PATH}")
    string(REPLACE "\\" "/" VENV_PACKAGES_DIR "${VENV_PACKAGES_DIR}")

    target_compile_definitions(${targetname} PRIVATE PYTHON_HOME_PATH="${PYTHON_HOME_PATH}")
    target_compile_definitions(${targetname} PRIVATE VENV_PACKAGES_DIR="${VENV_PACKAGES_DIR}")

    # generate python_helper.h
    generate_python_helper(${CMAKE_SOURCE_DIR}/include)
    target_include_directories(${targetname} PRIVATE ${CMAKE_SOURCE_DIR}/include)

endfunction()


function (generate_python_helper output_dir)
    # Set output path
    if (NOT output_dir)
        set(output_dir "${CMAKE_SOURCE_DIR}/include")
    endif()

    if (NOT EXISTS ${output_dir})
        message(WARNING "Output directory does not exist. Creating: ${output_dir}")
        file(MAKE_DIRECTORY ${output_dir})
    endif()

    set(OUTPUT_FILE "${output_dir}/python_helper.h")

    # Generate the header file
    file(WRITE ${OUTPUT_FILE} "// This file is auto-generated by CMake. Avoid to edit it manually.
#pragma once

#include <pybind11/pybind11.h>
#include <pybind11/embed.h>
#include <string>
#include <filesystem>
#include <iostream>
#include <stdexcept>

#ifdef _WIN32
#include <windows.h>
#endif

namespace py = pybind11;

// Configure Python home environment (must be called before interpreter initialization)
void configure_python_home()
{
#ifdef _WIN32
#ifdef PYTHON_HOME_PATH
    SetEnvironmentVariableA(\"PYTHONHOME\", PYTHON_HOME_PATH);
#else
    std::cerr << \"PYTHON_HOME_PATH is not defined.\" << std::endl;
    throw std::runtime_error(\"PYTHON_HOME_PATH is not defined.\");
#endif
#endif
}

// Setup virtual environment paths (must be called after interpreter initialization)
void setup_virtual_environment()
{
#ifdef VENV_PACKAGES_DIR
    std::string venv_packages_dir = VENV_PACKAGES_DIR;

    // Convert backslashes to forward slashes for Python path compatibility
    for (char &c : venv_packages_dir)
    {
        if (c == '\\\\')
            c = '/';
    }

    // Add virtual environment path to sys.path if it exists and not already added
    std::string setup_code =
        \"import sys\\n\"
        \"import os\\n\"
        \"venv_path = r'\" + venv_packages_dir + \"'\\n\"
        \"if os.path.exists(venv_path) and venv_path not in sys.path:\\n\"
        \"    sys.path.insert(0, venv_path)\\n\";

    py::exec(setup_code);
#else
    std::cerr << \"VENV_PACKAGES_DIR is not defined.\" << std::endl;
    throw std::runtime_error(\"VENV_PACKAGES_DIR is not defined.\");
#endif
}

// Add python script directory to sys.path (must be called after interpreter initialization).
// `script_dir` is relative to project root, default is \"src\"
void setup_script_directory(std::string script_dir = \"src\")
{
    // this would be different based on your project structure
    auto project_root = std::filesystem::path(__FILE__).parent_path().parent_path();
    auto script_abs_dir = project_root.append(script_dir).string();

    // Check if the directory exists
    if (!std::filesystem::exists(script_abs_dir) || !std::filesystem::is_directory(script_abs_dir))
    {
        std::cerr << \"Script directory does not exist: \" << script_abs_dir << std::endl;
        throw std::runtime_error(\"Script directory does not exist: \" + script_abs_dir);
    }

    // Convert backslashes to forward slashes for Python path compatibility
    for (char &c : script_abs_dir)
    {
        if (c == '\\\\')
            c = '/';
    }

    std::string setup_code =
        \"import sys, os\\n\"
        \"src_path = os.path.abspath('\" + script_abs_dir + \"')\\n\"
        \"if src_path not in sys.path:\\n\"
        \"    sys.path.insert(0, src_path)\\n\";

    py::exec(setup_code);
}
")
    
    message(STATUS "Generated python_helper.h at: ${OUTPUT_FILE}")
    
endfunction()


# --------------------------------------------------------------------------------
# Setup target
# --------------------------------------------------------------------------------

set(targetname demo)
add_executable(${targetname} src/main.cpp)
setup_python(${targetname})


